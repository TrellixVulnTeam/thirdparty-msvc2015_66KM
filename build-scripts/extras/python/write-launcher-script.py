""" Generate relocatable launcher scripts (python  +.cmd file) for entry points in Python packages.

The default .exe files generated by setuptools/pip are not relocatable and
are unsuitable for our installers.
"""
from __future__ import print_function

# Use the regex defined in pip to pull out entry points
from pip._vendor.distlib.util import ENTRY_RE

import argparse
import os
import sys

PY_EXECUTABLE = "%~dp0\..\python.exe"

# This template is the one used by IPython: https://github.com/ipython/ipython/blob/af17558781ff8d6ac0629e809399d67235a7e1db/setupbase.py#L355
SCRIPT_SRC  = """#!{executable}
# This script was automatically generated by write-launcher-script.py
if __name__ == '__main__':
    from {mod} import {func}
    {func}()
"""

CMD_SRC= """@echo off
REM This script was automatically generated by write-launcher-script.py
setlocal enableextensions
REM python launcher script. Uses a relative path to the Python
REM executable to ensure it is relocatable
set _this_dir=%~dp0
{executable} %_this_dir%{startupscript} %*
"""

class EntryPoint(object):
    
    def __init__(self, name, modname, entry_func):
        self.name = name
        self.modname = modname
        self.entry_func = entry_func

# -----------------------------------------------------------------------------

class ScriptWriter(object):

    def __init__(self, target_dir, filename):
        self.target_dir = target_dir
        self.filename = filename
    
    def make(self):
        if not os.path.exists(self.target_dir):
            self.mkpath(self.targer_dir)
        template = self.get_template()
        context = self.get_context()
        outfile = os.path.join(self.target_dir, self.filename)
        print('Writing script to', outfile)
        with open(outfile, 'w') as f:
            f.write(template.format(**context))
        self.post_process(outfile)
        return outfile
    
    def post_process(self, outfile):
        pass
    
    def mkpath(self, path):
        os.mkdir(path)

# -----------------------------------------------------------------------------

class PyLauncherWriter(ScriptWriter):

    def __init__(self, target_dir, entry_point):
        self.modname, self.entry_func = entry_point.modname, entry_point.entry_func
        super(PyLauncherWriter, self).__init__(target_dir, entry_point.name)
    
    def get_template(self):
        return SCRIPT_SRC
    
    def get_context(self):
        return {'executable':PY_EXECUTABLE, 'mod':self.modname, 
                'func':self.entry_func}

# -----------------------------------------------------------------------------

class WindowsCmdMaker(ScriptWriter):

    def __init__(self, startupscript, rm_exe=True):
        dirpath, filename = os.path.split(startupscript)
        filepath_ne, _ = os.path.splitext(filename)
        super(WindowsCmdMaker, self).__init__(dirpath, filepath_ne + ".cmd")
        self.rm_exe = rm_exe
        self.startupscript = filename

    def get_template(self):
        return CMD_SRC

    def get_context(self):
        return {'executable':PY_EXECUTABLE, 'startupscript':self.startupscript}
        
    def post_process(self, outfile):
        if self.rm_exe:
            filepath_ne, _ = os.path.splitext(outfile)
            exefile = filepath_ne + ".exe"
            if os.path.exists(exefile):
                print("Removing '{0}'".format(exefile))
                os.remove(exefile)

# -----------------------------------------------------------------------------

def write_console_scripts(entry_points_file, target_dir, rm_exe):
    entry_points = get_entry_points(args.entry_points_file)
    for entry_point in entry_points:
        launcher_writer = PyLauncherWriter(target_dir, entry_point)
        filename = launcher_writer.make()
        cmd_writer = WindowsCmdMaker(filename, rm_exe=rm_exe)
        cmd_writer.make()

# -----------------------------------------------------------------------------

def get_entry_points(entry_points_file):
    """Return entry points of console entry points from a given entry point file.
    Only those that match the current Python major version are returned. It is assumed
    that the any numeric specifier at the end of the name is the version specifier

    An example:

    [console_scripts]
    pip = pip:main
    pip3 = pip:main
    pip3.4 = pip:main
    
    would return ["pip = pip:main"]
    """

    # open with universal line endings
    f = open(entry_points_file, 'rU')
    specs = []
    script_section = False
    for line in f:
        line = line.strip()
        if line == "":
            continue
        if line.startswith("["):
            script_section = False
            if "console_scripts" or "gui_scripts" in line:
                script_section = True
            continue
        if not script_section:
          continue
        match = ENTRY_RE.match(line)
        if match:
            name = match.group('name') 
            entry_point = match.group('callable')
            modname, entry_func = entry_point.split(':')
            specs.append(EntryPoint(name, modname, entry_func))

    return specs

# -----------------------------------------------------------------------------

if __name__ == '__main__':
    # Parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("entry_points_file", help="Path of file containing a list of entry points")
    parser.add_argument("--destdir", help="The directory to install the scripts. Default=os.path.dirname(sys.executable)/Scripts")
    parser.add_argument("--rm_exe", help="If a .exe of the same stem exists remove it", action="store_true")
    args = parser.parse_args()

    build_dir = args.destdir
    if build_dir is None:
        build_dir = os.path.join(os.path.dirname(sys.executable), 'Scripts')

    write_console_scripts(args.entry_points_file, build_dir, args.rm_exe)
